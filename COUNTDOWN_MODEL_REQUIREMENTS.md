# 红绿灯倒计时模型修改需求

## 📋 当前问题

### 现状分析
- **对象名称**：`MD_HongLvDeng_WenZi` (及 8个实例)
- **当前实现**：带"88"纹理的Mesh平面
- **问题**：
  1. UV映射不完整（只覆盖54%的纹理空间）
  2. UV中心偏移（V=0.3294而不是0.5）
  3. 两组红绿灯朝向不一致（东西向和南北向）
  4. 前端需要大量计算（UV偏移、旋转矩阵、Canvas绘制）

### 代码复杂度
- 前端需要创建Mesh平面
- 需要计算UV对齐的Canvas绘制位置
- 需要为不同组设置不同的旋转角度
- 性能开销：Canvas实时绘制 + 纹理更新 + Mesh渲染

---

## ✅ 推荐方案（按优先级）

### 方案1：3D Text 对象（最优）

**建模要求：**

```
对象：MD_HongLvDeng_WenZi（及其8个实例）

替换为：3D Text对象
- 文本内容：初始值 "0" 或 "88"
- 字体：等宽字体（如 Arial, Roboto Mono）
- 大小：适配倒计时显示区域
- 位置：倒计时显示区域中心
- 朝向：朝外（面向观察者，与红绿灯灯面平行）
- 对齐：水平居中、垂直居中
- 材质：自发光材质，白色，高强度
```

**前端代码：**
```javascript
// 超级简单！
const countdownText = scene.getObjectByName('MD_HongLvDeng_WenZi');
countdownText.text = "35";  // 直接设置文本
```

**优点：**
- ✅ 前端代码极简
- ✅ 无需UV计算
- ✅ 无需Canvas绘制
- ✅ 无需旋转计算
- ✅ 性能最优
- ✅ 文本自动居中

**缺点：**
- ❌ Three.js/glTF对3D Text支持有限
- ❌ 可能需要转换为Mesh

---

### 方案2：正确UV映射的平面（推荐）

**建模要求：**

```
对象：MD_HongLvDeng_WenZi（及其8个实例）

修改要求：
1. UV映射：
   - UV范围：[0, 0] 到 [1, 1]（覆盖100%纹理空间）
   - UV中心：(0.5, 0.5)（纹理正中心）
   - 无拉伸、无变形
   
2. 朝向统一：
   - 所有8个实例朝向一致（都朝外）
   - 法线方向正确（朝向观察者）
   - 无需前端旋转

3. 位置：
   - 在倒计时显示区域中心
   - 与红绿灯灯面平行
   - Z轴稍微向前（避免z-fighting）

4. 尺寸：
   - 宽高比 2:1 或 3:1（适配两位数）
   - 大小适配显示区域

5. 材质（可选）：
   - 移除"88"纹理（或设为完全透明）
   - 支持自发光
```

**验证方法（在Blender中）：**
```
1. 选择 MD_HongLvDeng_WenZi
2. 进入UV编辑模式
3. 查看UV覆盖范围：
   ✅ 应该填满整个[0,1]格子
   ✅ UV中心在格子正中间
4. 应用测试纹理（如棋盘格）：
   ✅ 无变形
   ✅ 居中显示
5. 检查所有8个实例朝向一致
```

**前端代码：**
```javascript
// 简单！
const countdown = scene.getObjectByName('MD_HongLvDeng_WenZi');
countdown.material.map = createNumberTexture("35");  // 绘制到Canvas
```

**优点：**
- ✅ 前端代码简单
- ✅ 无需复杂旋转计算
- ✅ UV居中，Canvas绘制简单
- ✅ 兼容性好

**缺点：**
- ⚠️ 仍需Canvas绘制
- ⚠️ 仍需纹理更新

---

### 方案3：空对象占位符（灵活）

**建模要求：**

```
对象：MD_HongLvDeng_WenZi（及其8个实例）

替换为：Empty对象（空物体）
- 类型：Plain Axes 或 Sphere
- 位置：倒计时显示区域中心
- 旋转：(0, 0, 0)（无旋转）
- 命名：保持 MD_HongLvDeng_WenZi
```

**前端代码：**
```javascript
// 前端创建Sprite或TextGeometry
const emptyPos = scene.getObjectByName('MD_HongLvDeng_WenZi');
const sprite = createTextSprite("35");
sprite.position.copy(emptyPos.position);
scene.add(sprite);
```

**优点：**
- ✅ 最灵活
- ✅ 前端完全控制渲染方式

**缺点：**
- ❌ 前端仍需创建渲染对象
- ❌ 位置可能需要微调

---

## 🎯 最终推荐：方案2（正确UV映射的平面）

### 为什么选择方案2？
1. **兼容性好**：glTF标准支持
2. **修改成本低**：只需修复UV，不改模型结构
3. **前端简单**：无需复杂计算
4. **性能可控**：Canvas绘制可优化

---

## 📝 给建模工程师的具体步骤（Blender）

### 步骤1：打开项目
```
1. 打开 sandbox.blend 项目文件
2. 找到红绿灯对象组
```

### 步骤2：选择倒计时对象
```
1. 在大纲视图找到：
   - MD_HongLvDeng_WenZi
   - MD_HongLvDeng_WenZi_(1)
   - ... 到 _(7)
2. 按住Shift多选所有8个
```

### 步骤3：修复UV映射
```
1. Tab 进入编辑模式
2. A 选择所有顶点
3. U 打开UV菜单
4. 选择 "Unwrap" 或 "Smart UV Project"
   - 如果选Smart UV：勾选"缩放至边界框"
5. 切换到UV编辑器
6. A 选择所有UV点
7. S 缩放UV到填满整个[0,1]格子
8. G 移动UV到正中心
```

### 步骤4：保持朝向不变（重要！）
```
⚠️ 不要修改红绿灯的朝向或旋转
✅ 保持当前朝向（和实际场景一致）

说明：
- 2组红绿灯朝东西向（索引0, 2）
- 6组红绿灯朝南北向（索引1, 3, 4, 5, 6, 7）
- 这是正确的，反映真实场景布局
- 前端会根据不同朝向设置对应的旋转角度
```

### 步骤5：验证UV
```
1. 创建测试纹理：
   - 新建512x512图片
   - 画一个大数字"8"在正中间
2. 应用到材质的Map
3. 在3D视图检查：
   ✅ 数字"8"居中显示
   ✅ 数字不变形
   ✅ 所有8个实例UV映射一致
   ⚠️ 朝向不同是正常的（保持实际场景布局）
```

### 步骤6：导出
```
1. 选择整个沙盘场景
2. File → Export → glTF 2.0 (.glb)
3. 设置：
   ✅ Format: glTF Binary (.glb)
   ✅ Include: Selected Objects 或 Visible Objects
   ✅ Transform: +Y Up
   ✅ Geometry: Apply Modifiers
4. 导出为 sandbox.glb
```

---

## ✅ 验证清单

**导出后验证（在应用中）：**

在浏览器控制台运行UV检查脚本：

```javascript
// 应该输出：
✅ UV覆盖范围：95%+ x 95%+
✅ UV中心点：(0.5, 0.5) 或接近
✅ 所有8个实例UV一致
```

**视觉验证：**
- [ ] 数字显示在正确位置（倒计时区域中心）
- [ ] 数字不变形
- [ ] 数字清晰可见
- [ ] 所有8个红绿灯效果一致
- [ ] 旋转沙盘时，数字跟随红绿灯旋转

---

## 📞 常见问题

### Q1：UV怎么知道是否正确？
**A**：在UV编辑器中，UV应该填满整个格子（从左下角[0,0]到右上角[1,1]），且居中对称。

### Q2：如何确保朝向一致？
**A**：选择一个朝向正确的对象，复制其旋转值到其他对象。或者使用"Align Rotation"功能。

### Q3：为什么需要UV覆盖100%？
**A**：前端会在512x512的Canvas上绘制数字，UV覆盖100%意味着整个Canvas都能映射到模型上，数字才能完整显示。

### Q4：可以用其他软件吗？
**A**：可以，任何3D建模软件都行（Maya, 3ds Max, C4D），只要最终导出glTF格式且UV正确。

---

## 📊 修改前后对比

| 项目 | 修改前 | 修改后 |
|------|--------|--------|
| UV覆盖 | 54% | **100%** |
| UV中心 | (0.52, 0.33) | **(0.5, 0.5)** |
| 朝向 | 不一致 | **统一** |
| 前端代码 | 200+行 | **<50行** |
| 性能 | 8个Mesh+Canvas | **只用材质** |
| 维护性 | 差 | **好** |

---

**创建日期**：2025-10-26  
**文档版本**：1.0  
**联系方式**：[开发团队]

